% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/window.R
\name{window_space}
\alias{window_space}
\title{Apply a moving window operation or convolution kernel over the spatial dimensions of a data cube}
\usage{
window_space(x, expr, ..., kernel, window, keep_bands = FALSE, pad = NA)
}
\arguments{
\item{x}{source data cube}

\item{expr}{either a single string, or a vector of strings, defining which reducers will be applied over which bands of the input cube}

\item{...}{optional additional expressions (if expr is not a vector)}

\item{kernel}{two dimensional kernel (matrix) applied as convolution (must have odd number of rows and columns)}

\item{window}{integer vector with two elements defining the size of the window before and after a cell, the total size of the window is window[1] + 1 + window[2]}

\item{keep_bands}{logical; if FALSE (the default), original data cube bands will be dropped.}

\item{pad}{Padding method applied to the borders; use NULL for no padding, a numeric a fill value, or one of "REPLICATE", "REFLECT", "REFLECT_PIXEL"}
}
\value{
proxy data cube object
}
\description{
Create a proxy data cube, which applies a convolution kernel or an aggregation functions on two-dimensional moving 
windows sliding over spatial slices of a data cube. The function can either execute a predefined agggregation function or 
apply a custom convolution kernel. Among others, use cases include image processing (edge detection, median filter noise reduction, etc.) and
enriching pixel values with local neighborhood properties (e.g. to use as predictor variables in ML models).
}
\details{
The function either applies a kernel convolution (if the \code{kernel} argument is provided) or one or more built-in reducer function 
over moving windows. In the former case, the kernel convolution will be applied over all bands of the input 
cube, i.e., the output cube will have the same number of bands as the input cubes. 
To apply one or more reducer functions, the window argument must be provided as a vector with two integer sizes in the order y, x.
Several string expressions can be provided to create multiple bands in the output cube.

Notice that expressions have a very simple format: the reducer is followed by the name of a band in parentheses. You cannot add
more complex functions or arguments. Possible reducers currently include "min", "max", "sum", "prod", "count", "mean", "median", "var", and "sd".
}
\note{
Implemented reducers will ignore any NAN values (as \code{na.rm = TRUE} does).

Calling this function consecutively many times may result in long computation times depending on chunk and window sizes due to the need to read adjacent data cube chunks.

This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
}
\examples{
# create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files <- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
                          bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v, chunking = c(1,1000,1000)) 
L8.cube = select_bands(L8.cube, c("B04", "B05")) 
L8.cube.mean5x5 = window_space(L8.cube, kernel = matrix(1/25, 5, 5))
L8.cube.mean5x5

L8.cube.med_sd = window_space(L8.cube, "median(B04)" ,"sd(B04)", "median(B05)", "sd(B05)", 
                              window = c(5,5), keep_bands = TRUE)
L8.cube.med_sd

}
